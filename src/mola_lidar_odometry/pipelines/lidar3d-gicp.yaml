# =====================================================================================
# Pipeline: GICP (Generalized ICP) with cov-to-cov pairings
#
# For paper references, see https://github.com/MOLAorg/mola_lidar_odometry/
#
# This file holds parameters for mola::LidarOdometry,
# for use either programmatically calling initialize(), or from a MOLA system
# launch file. See "mola-cli-launchs/*" examples or the main project docs:
# =====================================================================================

params:
  pipeline_name: "GICP (Generalized ICP) with cov-to-cov pairings" # For display/debug only

  # These sensor labels will be handled as LIDAR observations:
  # Can be overridden with cli flag --lidar-sensor-label
  lidar_sensor_labels: ["${MOLA_LIDAR_NAME|lidar}", "/ouster/points"]

  multiple_lidars:
    lidar_count: ${MOLA_LIDAR_COUNT|1} # useful only if using several lidar_sensor_labels or regex's.
    max_time_offset: ${MOLA_LIDAR_MAX_TIME_OFFSET|0.1} # [s]

  # These sensor labels will be handled as IMU observations:
  imu_sensor_label: "${MOLA_IMU_NAME|imu}"

  # These sensor labels will be handled as GNSS (GPS) (For storage in simplemap only)
  gnss_sensor_label: "${MOLA_GPS_NAME|gps}"

  # Optionally, drop lidar data too close in time:
  min_time_between_scans: 1e-3 # [seconds]

  # Parameters for max sensor range automatic estimation:
  max_sensor_range_filter_coefficient: 0.95
  absolute_minimum_sensor_range: ${MOLA_ABS_MIN_SENSOR_RANGE|5.0}

  # If enabled, vehicle twist will be optimized during ICP
  # enabling better and more robust odometry in high dynamics motion without an IMU.
  optimize_twist: "${MOLA_OPTIMIZE_TWIST|false}"
  optimize_twist_max_corrections: 8 # (max number of corrections)
  optimize_twist_rerun_min_trans: 0.15 # [m]
  optimize_twist_rerun_min_rot_deg: 0.75 # [deg]

  # When publishing pose updates, the reference frame for both, estimated robot poses, and the local map.
  publish_reference_frame: "${MOLA_LO_PUBLISH_REF_FRAME|odom}"

  # When publishing pose updates, the vehicle frame name.
  publish_vehicle_frame: "${MOLA_LO_PUBLISH_VEHICLE_FRAME|base_link}"

  # If enabled, deskewed scans will be published (so, they will be available as ROS2 messages), mostly for visualization.
  # This may slow-down the system, so it is disabled by default.
  publish_deskewed_scans: "${MOLA_LO_PUBLISH_DESKEWED_SCANS|false}"

  # How often to update the local map model:
  local_map_updates:
    enabled: "${MOLA_MAPPING_ENABLED|true}"
    load_existing_local_map: ${MOLA_LOAD_MM|""}
    save_final_local_map: ${MOLA_SAVE_MM|""} # If not empty, saves the final local metric map to a ".mm" file

    # Idea: don't integrate scans with a high rotational speed since they are probably not correctly deskewed:
    min_translation_between_keyframes: "${MOLA_MIN_XYZ_BETWEEN_MAP_UPDATES|(0.1e-2 + sqrt(wx^2+wy^2+wz^2)*0.1)*ESTIMATED_SENSOR_MAX_RANGE}" # [m]
    min_rotation_between_keyframes: "${MOLA_MIN_ROT_BETWEEN_MAP_UPDATES|(15 + sqrt(wx^2+wy^2+wz^2)*500 )}" # [deg]

    # Should match the "remove farther than" option of the local metric map. "0" means deletion of distant key-frames is disabled
    max_distance_to_keep_keyframes: "${MOLA_LOCAL_MAP_MAX_SIZE|max(100.0, 1.50*ESTIMATED_SENSOR_MAX_RANGE)}" # [m]
    check_for_removal_every_n: 100
    publish_map_updates_every_n: ${MOLA_PUBLISH_LOCAL_MAP_UPDATES_EVERY_N|40}

  # Minimum ICP quality to insert it into the map:
  min_icp_goodness: ${MOLA_MINIMUM_ICP_QUALITY|0.50}

  # Adaptive threshold, as in the KISS-ICP paper:
  adaptive_threshold:
    enabled: true
    initial_sigma: 0.50 # [m]
    min_motion: ${MOLA_SIGMA_MIN_MOTION|0.04} # [m]
    maximum_sigma: ${MOLA_SIGMA_MAX_MOTION|0.50} # [m]
    icp_quality_controller_setpoint: 0.85
    kp: 2.0
    alpha: ${MOLA_ADAPT_THRESHOLD_ALPHA|0.99}

  # If enabled, a map will be stored in RAM and (if using the CLI) stored
  # to a ".simplemap" file for later use for localization, etc.
  simplemap:
    generate: ${MOLA_GENERATE_SIMPLEMAP|false} # Can be overridden with CLI flag --output-simplemap
    load_existing_simple_map: ${MOLA_LOAD_SM|""}

    save_final_map_to_file: ${MOLA_SIMPLEMAP_OUTPUT|'final_map.simplemap'}

    min_translation_between_keyframes: ${MOLA_SIMPLEMAP_MIN_XYZ|(1.0e-2 + sqrt(wx^2+wy^2+wz^2)*1.0)*ESTIMATED_SENSOR_MAX_RANGE} # m
    min_rotation_between_keyframes: ${MOLA_SIMPLEMAP_MIN_ROT|15 + sqrt(wx^2+wy^2+wz^2)*500} # deg

    generate_lazy_load_scan_files: ${MOLA_SIMPLEMAP_GENERATE_LAZY_LOAD|false} # If enabled, a directory will be create alongside the .simplemap and pointclouds will be externally serialized there.
    add_non_keyframes_too: ${MOLA_SIMPLEMAP_ALSO_NON_KEYFRAMES|false} # If enabled, all frames are stored in the simplemap, but non-keyframes will be without associated observations.
    save_gnss_max_age: 1.0 # [s] max age of GNSS observations to keep in the keyframe

    # If enabled, this will store deskewed scans into the keyframes of simplemaps.
    save_deskewed_scans: ${MOLA_SAVE_DESKEWED_SCANS|false}

  # Save the final trajectory in TUM format. Disabled by default.
  estimated_trajectory:
    save_to_file: ${MOLA_SAVE_TRAJECTORY|false}
    output_file: ${MOLA_TUM_TRAJECTORY_OUTPUT|'estimated_trajectory.tum'}

  # If run within a mola-cli container, and mola_viz is present, use these options
  # to show live progress:
  visualization:
    map_update_decimation: 10
    show_trajectory: true
    trajectory_rgba: [0.1, 0.1, 0.1, 1.0]
    show_current_observation: false # shows "live deskewed" LiDAR points
    show_last_deskewed_observations_decay: true # shows "live deskewed" LiDAR points over time
    last_deskewed_observations_point_size: ${MOLA_GUI_LAST_CLOUDS_POINT_SIZE|1.0}
    last_deskewed_observations_colormap: ${MOLA_GUI_LAST_CLOUDS_COLORMAP|cmJET} # mrpt::img::TColormap
    observations_initial_alpha: 0.10
    observations_decay_seconds: ${MOLA_GUI_CLOUDS_DECAY_SECS|10.0} # For deskewed clouds above
    current_observation_point_size: ${MOLA_GUI_CURRENT_CLOUD_POINT_SIZE|2.0}
    current_observation_colormap: ${MOLA_GUI_CURRENT_CLOUD_COLORMAP|cmHOT} # mrpt::img::TColormap
    current_observation_alpha: 0.20

    background_color_gray_level: "${MOLA_GUI_BACKGROUND_GRAY_LEVEL|0.3}"

    show_localmap: ${MOLA_GUI_SHOW_LOCAL_MAP|true}
    local_map_point_size: 1

    show_ground_grid: ${MOLA_GUI_SHOW_GROUND_GRID|true}
    ground_grid_spacing: 5.0 # [m]
    #current_pose_corner_size: 1.5
    model:
      - file: ${MOLA_VEHICLE_MODEL_FILE|""} # Default: none
        tf.x: ${MOLA_VEHICLE_MODEL_X|0.0} # deg
        tf.y: ${MOLA_VEHICLE_MODEL_Y|0.0} # deg
        tf.z: ${MOLA_VEHICLE_MODEL_Z|0.0} # deg
        tf.yaw: ${MOLA_VEHICLE_MODEL_YAW|0.0} # deg
        tf.pitch: ${MOLA_VEHICLE_MODEL_PITCH|0.0} # deg
        tf.roll: ${MOLA_VEHICLE_MODEL_ROLL|90.0} # deg

  # Profile the main steps of the odometry pipeline:
  pipeline_profiler_enabled: ${MOLA_PROFILER|true}
  # Profile the internal steps of the ICP implementation:
  icp_profiler_enabled: ${MOLA_PROFILER|true}

  # If set to false, the odometry pipeline will ignore incoming observations
  # until active is set to true (e.g. via the GUI).
  start_active: "${MOLA_START_ACTIVE|true}"

  # [m^-2] Minimum motion model covariance (in X,Y,Z) to consider a state estimation as valid as prior for ICP.
  min_motion_model_xyz_cov_inv: 1.0

  # Generate CSV with the evolution of internal variables:
  debug_traces:
    save_to_file: "${MOLA_SAVE_DEBUG_TRACES|false}"
    output_file: "${MOLA_DEBUG_TRACES_FILE|mola-lo-traces.csv}"

  # Optional filters to discard incomplete 3D scans from
  # faulty network, missing UDP packets, etc.
  observation_validity_checks:
    enabled: "${MOLA_ENABLE_OBS_VALIDITY_FILTER|false}"
    check_layer_name: "raw"
    minimum_point_count: "${MOLA_OBS_VALIDITY_MIN_POINTS|1000}"

# re-localization method to use at start up:
initial_localization:
  method: "${MOLA_LO_INITIAL_LOCALIZATION_METHOD|InitLocalization::FixedPose}"
  fixed_initial_pose:
    [
      "${MOLA_INITIAL_X|0.0}",
      "${MOLA_INITIAL_Y|0.0}",
      "${MOLA_INITIAL_Z|0.0}",
      "${MOLA_INITIAL_YAW|0.0}",
      "${MOLA_INITIAL_PITCH|0.0}",
      "${MOLA_INITIAL_ROLL|0.0}",
    ]
  imu_initial_calibration_sample_count: "${MOLA_LO_INITIAL_IMU_SAMPLES|400}"
  imu_initial_calibration_max_age: 5.0

# If "icp_settings_without_vel" is not defined here, defaults to be the same than 'icp_settings_with_vel'
# ICP settings can be included from an external YAML file if desired, or defined
# in this same YAML for self-completeness:
# Include example:
#icp_settings_with_vel: $include{./icp-pipeline-default.yaml}

# ICP parameters for a regular time step:
icp_settings_with_vel:
  # mp2p_icp ICP pipeline configuration file, for use in ICP
  # odometry and SLAM packages.
  #
  # YAML configuration file for use with the CLI tool mp2p-icp-run or
  # programmatically from function mp2p_icp::icp_pipeline_from_yaml()
  #
  class_name: mp2p_icp::ICP

  # See: mp2p_icp::Parameter
  params:
    maxIterations: ${MOLA_MAX_ICP_ITERATIONS|25}
    minAbsStep_trans: 1e-3
    minAbsStep_rot: 1e-4

    #debugPrintIterationProgress: true  # Print iteration progress
    #generateDebugFiles: true  # Can be override with env var "MP2P_ICP_GENERATE_DEBUG_FILES=1"
    saveIterationDetails: ${MP2P_ICP_LOG_FILES_SAVE_DETAILS|false} # Store partial solutions and pairings for each ICP iteration
    decimationIterationDetails: ${MP2P_ICP_LOG_FILES_SAVE_DETAILS_DECIMATION|3}
    debugFileNameFormat: "icp-logs/icp-run-${SEQ|NO_SEQ}-$UNIQUE_ID-local_$LOCAL_ID$LOCAL_LABEL-to-global_$GLOBAL_ID$GLOBAL_LABEL.icplog"
    decimationDebugFiles: ${MP2P_ICP_LOG_FILES_DECIMATION|10}

  solvers:
    - class: mp2p_icp::Solver_GaussNewton
      params:
        maxIterations: 1
        robustKernel: "${MOLA_LO_ROBUST_KERNEL|RobustKernel::GemanMcClure}"
        robustKernelParam: "${MOLA_LO_ROBUST_KERNEL_PARAM|6.0}" # In GICP, errors are normalized by covariance
        #innerLoopVerbose: true

  # Sequence of one or more pairs (class, params) defining mp2p_icp::Matcher
  # instances to pair geometric entities between pointclouds.
  matchers:
    - class: mp2p_icp::Matcher_Cov2Cov
      params:
        threshold: "2.0*ADAPTIVE_THRESHOLD_SIGMA"
        pairingsPerPoint: 1
        allowMatchAlreadyMatchedGlobalPoints: true # faster
        # Both layers here must be of type 'mola::KeyframePointCloudMap'
        layerMatches:
          - {
              global: "${MOLA_LOCALMAP_LAYER_NAME|localmap}",
              local: "observation",
            }

  quality:
    - class: mp2p_icp::QualityEvaluator_PairedRatio
      params: ~ # none required

# Local map updates:
# Very first observation: Use the mp2p_icp pipeline generator to create the local map:
localmap_generator:
  # Generators:
  #
  # One filter object will be created for each entry, instancing the given class,
  # and with the given parameters. Filters are run in definition order on the
  # incoming raw CObservation objects.
  #
  - class_name: mp2p_icp_filters::Generator
    params:
      target_layer: "${MOLA_LOCALMAP_LAYER_NAME|localmap}"
      throw_on_unhandled_observation_class: true
      process_class_names_regex: "" # NONE: don't process observations in the generator.
      #process_sensor_labels_regex: '.*'
      # metric_map_definition_ini_file: '${CURRENT_YAML_FILE_PATH}/localmap_definition_voxelmap.ini'

      metric_map_definition:
        # Any class derived from mrpt::maps::CMetricMap https://docs.mrpt.org/reference/latest/group_mrpt_maps_grp.html
        class: mola::KeyframePointCloudMap
        plugin: "libmola_metric_maps.so" # Import additional custom user-defined map classes (search in LD_LIBRARY_PATH)
        creationOpts:
          max_search_keyframes: 3
          k_correspondences_for_cov: 20
        insertOpts:
          remove_frames_farther_than: "${MOLA_LOCAL_MAP_MAX_SIZE|$f{max(100.0, 1.50*ESTIMATED_SENSOR_MAX_RANGE)}}" # [m]
        likelihoodOpts: ~ # none required
        renderOpts:
          color.A: 0.25 # [0,1] Use this alpha value for points, RGB from colormap
          colormap: "cmHOT" # cmJET, cmHOT, cmGRAYSCALE
          recolorByPointField: ${MOLA_GUI_LOCAL_MAP_COLOR_BY_COORDINATE|intensity} # x,y,z,ring, intensity, ambient, etc.
          max_points_per_kf: ${MOLA_LOCALMAP_VIZ_MAX_POINTS_PER_KF|10000} # Max number of points to render per keyframe
          max_overall_points: ${MOLA_LOCALMAP_VIZ_MAX_POINTS_OVERALL|500000} # Max number of points to render overall (e.g. to avoid FoxGlove WS overflow)
          #point_size: 1.0  # superseded by visualization.local_map_point_size above

# ---------------------------------------------------------------------------------
# LIDAR observations are, first, loaded using a generator
# from "observations_generator".
# then, optionally, filtered before being registered with ICP
# against the local map with filter "observations_filter_1st_pass".
# ---------------------------------------------------------------------------------
observations_generator:
  # Generators:
  #
  # One filter object will be created for each entry, instancing the given class,
  # and with the given parameters. Filters are run in definition order on the
  # incoming raw CObservation objects.
  #
  - class_name: mp2p_icp_filters::Generator
    params:
      name: "Generator (raw)"
      target_layer: "raw"
      throw_on_unhandled_observation_class: true
      process_class_names_regex: ".*"
      process_sensor_labels_regex: ".*"

  # This just creates an empty layer of the custom class 'mola::KeyframePointCloudMap'
  - class_name: mp2p_icp_filters::Generator
    params:
      name: "Generator (obs)"
      target_layer: "observation"
      throw_on_unhandled_observation_class: true
      process_class_names_regex: "" # NONE: don't process observations in the generator.
      #process_sensor_labels_regex: '.*'
      # metric_map_definition_ini_file: '${CURRENT_YAML_FILE_PATH}/localmap_definition_voxelmap.ini'

      metric_map_definition:
        # Any class derived from mrpt::maps::CMetricMap https://docs.mrpt.org/reference/latest/group_mrpt_maps_grp.html
        class: mola::KeyframePointCloudMap
        plugin: "libmola_metric_maps.so" # Import additional custom user-defined map classes (search in LD_LIBRARY_PATH)
        creationOpts: ~ # none required
        insertOpts: ~
        likelihoodOpts: ~ # none required
        renderOpts: ~

# this pipeline is required so "SENSOR_TIME_OFFSET" has a different value for each independent LiDAR sensor
# in setups with multiple LiDARs:
observations_filter_adjust_timestamps:
  # If twist estimation within ICP is enabled, this defines
  # the moment for which twist is estimated:
  - class_name: mp2p_icp_filters::FilterAdjustTimestamps
    params:
      pointcloud_layer: "raw"
      silently_ignore_no_timestamps: true
      time_offset: "SENSOR_TIME_OFFSET"
      method: "${MOLA_SCAN_POINT_STAMPS_ADJUST_METHOD|TimestampAdjustMethod::MiddleIsZero}"

observations_filter_1st_pass:
  # Filters:
  #
  # One filter object will be created for each entry, instancing the given class,
  # and with the given parameters. Filters are run in definition order on the
  # input metric_map_t object.

  - class_name: mp2p_icp_filters::FilterDecimateAdaptive
    params:
      name: "FilterDecimateAdaptive (map)"
      input_pointcloud_layer: "raw"
      output_pointcloud_layer: "decimated_unfiltered"
      voxel_size: "${MOLA_CLOUD_DECIMATION_VOXEL_SIZE|0.15}" # [m]
      desired_output_point_count: "${MOLA_DECIMATED_POINTS_MAP|10000}"
      parallelization_grain_size: 8000 # When TBB is enabled, the grainsize for splitting the input clouds into threads

  # Remove points too close, to prevent "noise" from the vehicle,
  # the person next to the robot, etc.
  - class_name: mp2p_icp_filters::FilterByRange
    params:
      input_pointcloud_layer: "decimated_unfiltered"
      output_layer_between: "decimated_skewed_for_map"
      range_min: "${MOLA_MINIMUM_RANGE_FILTER|max(1.0, 0.03*ESTIMATED_SENSOR_MAX_RANGE)}"
      range_max: 1.2*ESTIMATED_SENSOR_MAX_RANGE
      metric_l_infinity: true

  - class_name: mp2p_icp_filters::FilterDecimateAdaptive
    params:
      name: "FilterDecimateAdaptive (icp)"
      input_pointcloud_layer: "decimated_skewed_for_map"
      output_pointcloud_layer: "decimated_skewed_for_icp"
      voxel_size: "${MOLA_CLOUD_DECIMATION_VOXEL_SIZE|0.10}" # [m]
      desired_output_point_count: "${MOLA_DECIMATED_POINTS_ICP|3000}"
      parallelization_grain_size: 8000 # When TBB is enabled, the grainsize for splitting the input clouds into threads

# 2nd pass:
observations_filter_2nd_pass:
  - class_name: mp2p_icp_filters::FilterDeleteLayer
    params:
      pointcloud_layer_to_remove: ["decimated_map", "decimated_icp"]
      error_on_missing_input_layer: false

  - class_name: mp2p_icp_filters::FilterDeskew
    params:
      name: "FilterDeskew (map)"
      input_pointcloud_layer: "decimated_skewed_for_map"
      output_pointcloud_layer: "decimated_for_map"
      method: "${MOLA_DESKEW_METHOD|MotionCompensationMethod::Linear}"
      silently_ignore_no_timestamps: ${MOLA_IGNORE_NO_POINT_STAMPS|true} # To handle more dataset types
      output_layer_class: "mrpt::maps::CPointsMapXYZI" # Keep intensity, ring, time channels

      # These (vx,...,wz) are variable names that must be defined via the
      # mp2p_icp::Parameterizable API to update them dynamically.
      twist: [vx, vy, vz, wx, wy, wz]

  - class_name: mp2p_icp_filters::FilterDeskew
    params:
      name: "FilterDeskew (icp)"
      input_pointcloud_layer: "decimated_skewed_for_icp"
      output_pointcloud_layer: "decimated_for_icp"
      method: "${MOLA_DESKEW_METHOD|MotionCompensationMethod::Linear}"
      silently_ignore_no_timestamps: ${MOLA_IGNORE_NO_POINT_STAMPS|true} # To handle more dataset types
      #output_layer_class: 'mrpt::maps::CPointsMapXYZI'  # Keep intensity, ring, time channels

      # These (vx,...,wz) are variable names that must be defined via the
      # mp2p_icp::Parameterizable API to update them dynamically.
      twist: [vx, vy, vz, wx, wy, wz]

  - class_name: mp2p_icp_filters::FilterMerge
    params:
      name: "FilterMerge (icp into obs)"
      input_pointcloud_layer: "decimated_for_icp"
      target_layer: "observation"

# final pass:
observations_filter_final_pass:
  # Remove layers to save memory and log file storage
  - class_name: mp2p_icp_filters::FilterDeleteLayer
    params:
      pointcloud_layer_to_remove:
        [
          "raw",
          "decimated_unfiltered",
          "decimated_skewed_for_map",
          "decimated_skewed_for_icp",
        ]

# To populate the local map, one or more observation layers are merged
# into the local map via this pipeline:
insert_observation_into_local_map:
  - class_name: mp2p_icp_filters::FilterMerge
    params:
      name: "FilterMerge (map into localmap)"
      input_pointcloud_layer: "decimated_for_map"
      target_layer: "${MOLA_LOCALMAP_LAYER_NAME|localmap}"
      input_layer_in_local_coordinates: true
      robot_pose:
        [robot_x, robot_y, robot_z, robot_yaw, robot_pitch, robot_roll]

# Pipeline starting from raw observations (passed through "Generator"), to be
# sent out for visualization of the sliding-window of recent clouds as a dense local map
observations_filter_deskew_for_visualization:
  - class_name: mp2p_icp_filters::FilterByRange
    params:
      input_pointcloud_layer: "raw"
      output_layer_between: "raw_filtered"
      range_min: "${MOLA_MINIMUM_RANGE_FILTER|max(1.0, 0.03*ESTIMATED_SENSOR_MAX_RANGE)}"
      range_max: 1.2*ESTIMATED_SENSOR_MAX_RANGE
      metric_l_infinity: true

  - class_name: mp2p_icp_filters::FilterDeskew
    params:
      name: "FilterDeskew (viz)"
      input_pointcloud_layer: "raw_filtered"
      output_pointcloud_layer: "viz"
      method: "${MOLA_DESKEW_METHOD|MotionCompensationMethod::Linear}"
      silently_ignore_no_timestamps: ${MOLA_IGNORE_NO_POINT_STAMPS|true} # To handle more dataset types
      output_layer_class: "mrpt::maps::CPointsMapXYZI" # Keep intensity only

      # These (vx,...,wz) are variable names that must be defined via the
      # mp2p_icp::Parameterizable API to update them dynamically.
      twist: [vx, vy, vz, wx, wy, wz]

  # Remove raw layer so it's not visible
  - class_name: mp2p_icp_filters::FilterDeleteLayer
    params:
      pointcloud_layer_to_remove: ["raw", "raw_filtered"]
